import random

class Agent:
    def __init__(self, group_str):
        """
		When we make an agent, weâ€™ll pass a string (X or O as a constructor).  
		In the constructor, the agent should randomly decide on a 
		threshold that should be a random between 0.1 and 0.9.
		"""

        self.group = group_str
        self.threshold = round(random.uniform(0.1, 0.9), 2)
        self.x = None # updated __init__ for agent access to x and y 
        self.y = None
        self.city = None

    def __str__(self):
        return self.group

    def compare(self, other):
        """
		This method should take in another Agent object
		return true if both the current object 
		and this one are of the same group.
		"""
        if other is None:
            return False
        return self.group == other.group

    def is_satisfied(self, agent_list):
        """
		This method will take in a list of neighboring agents 
		(generated by our City class) and return True if the 
		agent is satisfied (meaning it passes the threshold).  
		
		Be advised!  There will be elements in this list that
		are None type.
		"""
        same_neighbor = 0
        occupied = 0
        for i in agent_list:
            if i is not None:
                occupied += 1
                if self.compare(i):
                    same_neighbor += 1
        if occupied == 0:
            return False
        return (same_neighbor / occupied) >= self.threshold


    def choose_neighbor(self, empty_cells, max_new_cell=3):
        potential_new_cell = []
        count = 0
        for cell in empty_cells:
            if count < max_new_cell:
                potential_new_cell.append(cell)
                count += 1
                
		
        '''
    	def choose_neighbor is the creative portion to this assignment

		the agent may "choose" a cell based on its scoring and best_spot feature

    	cell must be empty in order to be a potential cell hence the for loop

    	set a boundary on potential new cells, this simulates close to our reality, ie; no infinite options of movement

        '''

        best_score = 0
        best_spot = None

        for x, y in potential_new_cell:
            neighbors = self.city.get_neighbors(x, y) # self.city.get_neighbors - assign all neighbors from x,y cell
            same = 0
            for i in neighbors:
                if i is not None and i.group == self.group: # if the cell is not empty, and agent is of same group - increment same var
                   same += 1
            if neighbors:
                score = same / len(neighbors)  
            else: 
                return None# calculate score based on surrounding neighbors

            if score > best_score:
                best_score = score
                best_spot = (x, y) # set best spot given if the current (x,y) score is higher than best score

        return best_spot
    
    '''
    update_move_agent is an updated verson of move_agent

    new spot is a variable defined from choose_neighbor, where empty cells are potential spots

    agent moves to new_x and new_y, the new spot chosen from the choose_neighbor method

    if new_spot exists, continue with the move agent operation
    '''

    def update_move_agent(self):
        empty_cells = self.city.get_empty_cells()
        new_spot = self.choose_neighbor(empty_cells) # updated logic for new_spot where agent "chooses" cell 
        if new_spot is not None:
            new_x, new_y = new_spot
            self.city.move_agent(self, new_x, new_y)
